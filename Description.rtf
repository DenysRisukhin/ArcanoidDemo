{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf600
{\fonttbl\f0\fswiss\fcharset0 Helvetica-Bold;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
\f3\fnil\fcharset0 Menlo-Bold;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red255\green255\blue255;\red0\green0\blue0;
\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c1\c1;\cssrgb\c100000\c100000\c99985;\cssrgb\c0\c1\c1;
\cssrgb\c100000\c100000\c99985;\cssrgb\c0\c1\c1;}
\margl1440\margr1440\vieww25720\viewh11200\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\b\fs36 \cf0 Ball velocity
\f1\b0\fs24 \
\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f2 \cf2 \cb3 	Vec2 m_ballStartingVelocity = Vec2(20.0f, -100.0f);\
\
	void Ball::update(float delta)\
	\{\
    		this->setPosition(getPosition() + m_velocity * delta);\
\

\f3\b\fs28 Ball direction\
\
	if collision detected\
\
		\cf4 \cb5 step 1\cf2 \cb3 \
			- set ball to correct pos\
				
\f2\b0\fs24 \cf4 \cb5 setPosition(m_gameFieldRect.left().x + getRadius(), getPosition().y);\
					or\
				\cf2 \cb3 setPosition(leftX - getRadius(), getPosition().y);\
\
			
\f3\b\fs28 \cf4 \cb5 - set gameFieldRectPos
\f2\b0\fs24 \cf2 \cb3 \
\
			
\f3\b\fs28 - set angel offset
\f2\b0\fs24 \
				\cf4 \cb5 angleOffset = -(float)M_PI / 2;\
\
	\cf2 \cb3 		\cf6 \cb3 \
\
			
\f3\b\fs28 - set
\f2\b0\fs24 \
				\cf2 \cb3 m_velocity.x *= -1;\
					or\
        		    m_velocity.y *= -1;\
\
\
		
\f3\b\fs28 \cf4 \cb5 step 2\
			\cf2 \cb3 - calculate 
\f2\b0\fs24 hitAngle\
				float hitAngle = (gameFieldRectPos + getPosition()).getAngle() + angleOffset;\

\f3\b\fs28 \
			- calculate velocityAngel\
				
\f2\b0\fs24 auto velocityAngle = -m_velocity.getAngle() + 0.5 * hitAngle;
\f3\b\fs28 \
\
			- calculate new ball direction\
				
\f2\b0\fs24 \cf6 \cb3  \cf2 \cb3 m_velocity = Vec2::forAngle(velocityAngle) * m_velocity.getLength();\
\

\f3\b\fs36 collisions \

\f2\b0\fs24 \
	- Ball with Walls\
\
		class GameFieldRect\cf6 \cb3 \
\
\cf2 \cb3 			m_gameFieldRect.setRect(Rect(m_visibleOrigin.x + widthLeftIndent, m_visibleOrigin.y, m_screenWinSize.width - widthRightIndent, m_gameFrameHeight));\
\
			m_gameframeWidth = m_gameFieldRect.getGameFieldRect().getMaxX() - m_gameFieldRect.getGameFieldRect().getMinX();\
\
\
\cf6 \cb3 			
\f3\b\fs28 \cf2 \cb3 left wall: right side touched
\f2\b0\fs24 \
\
			if ( getPosition().x < m_gameFieldRect.left().x + getRadius())\
        \{\
            log("left wall: right side touched");\
            setPosition(m_gameFieldRect.left().x + getRadius(), getPosition().y);\
            hitLeftRight = true;\
            \
            angleOffset = -(float)M_PI / 2;\
            \
            gameFieldRectPos = Vec2(m_gameFieldRect.left().x + getRadius(), m_gameFieldRect.left().y - getRadius());\
            \
//            setPosition(m_gameFieldRect.left().x + getRadius(), getPosition().y);\
//            m_velocity.x *= -1;\
            SoundManager::instance()->playFx(SoundManager::FX::Wall);\
        \}\
\
\
 if (hitLeftRight)\
        \{\
 //           Vec2 gameFieldRectPos(m_gameFieldRect.left().x + getRadius(), m_gameFieldRect.left().y - getRadius());\
//            //float hitAngle = (platform->getPosition() - getPosition()).getAngle() + angleOffset;\
//\
            float hitAngle = (gameFieldRectPos + getPosition()).getAngle() + angleOffset;\
\
            auto scalarVelocity = m_velocity.getLength();\
            auto velocityAngle = -m_velocity.getAngle() + 0.5 * hitAngle;\
\
            m_velocity = Vec2::forAngle(velocityAngle) * scalarVelocity;\
            m_velocity.x *= -1;\
            m_velocity.y *= -1;\
        \}\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
}